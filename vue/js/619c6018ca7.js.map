{"version":3,"sources":["webpack://webpack-web/./node_modules/_konva@8.3.10@konva/lib/Shape.js"],"names":[],"mappings":"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","file":"js/619c6018ca7.js","sourcesContent":["import { Konva } from './Global.js';\nimport { Transform, Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Node } from './Node.js';\nimport { getNumberValidator, getNumberOrAutoValidator, getStringValidator, getBooleanValidator, getStringOrGradientValidator, } from './Validators.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar HAS_SHADOW = 'hasShadow';\nvar SHADOW_RGBA = 'shadowRGBA';\nvar patternImage = 'patternImage';\nvar linearGradient = 'linearGradient';\nvar radialGradient = 'radialGradient';\nlet dummyContext;\nfunction getDummyContext() {\n    if (dummyContext) {\n        return dummyContext;\n    }\n    dummyContext = Util.createCanvasElement().getContext('2d');\n    return dummyContext;\n}\nexport const shapes = {};\nfunction _fillFunc(context) {\n    context.fill();\n}\nfunction _strokeFunc(context) {\n    context.stroke();\n}\nfunction _fillFuncHit(context) {\n    context.fill();\n}\nfunction _strokeFuncHit(context) {\n    context.stroke();\n}\nfunction _clearHasShadowCache() {\n    this._clearCache(HAS_SHADOW);\n}\nfunction _clearGetShadowRGBACache() {\n    this._clearCache(SHADOW_RGBA);\n}\nfunction _clearFillPatternCache() {\n    this._clearCache(patternImage);\n}\nfunction _clearLinearGradientCache() {\n    this._clearCache(linearGradient);\n}\nfunction _clearRadialGradientCache() {\n    this._clearCache(radialGradient);\n}\nexport class Shape extends Node {\n    constructor(config) {\n        super(config);\n        let key;\n        while (true) {\n            key = Util.getRandomColor();\n            if (key && !(key in shapes)) {\n                break;\n            }\n        }\n        this.colorKey = key;\n        shapes[key] = this;\n    }\n    getContext() {\n        Util.warn('shape.getContext() method is deprecated. Please do not use it.');\n        return this.getLayer().getContext();\n    }\n    getCanvas() {\n        Util.warn('shape.getCanvas() method is deprecated. Please do not use it.');\n        return this.getLayer().getCanvas();\n    }\n    getSceneFunc() {\n        return this.attrs.sceneFunc || this['_sceneFunc'];\n    }\n    getHitFunc() {\n        return this.attrs.hitFunc || this['_hitFunc'];\n    }\n    hasShadow() {\n        return this._getCache(HAS_SHADOW, this._hasShadow);\n    }\n    _hasShadow() {\n        return (this.shadowEnabled() &&\n            this.shadowOpacity() !== 0 &&\n            !!(this.shadowColor() ||\n                this.shadowBlur() ||\n                this.shadowOffsetX() ||\n                this.shadowOffsetY()));\n    }\n    _getFillPattern() {\n        return this._getCache(patternImage, this.__getFillPattern);\n    }\n    __getFillPattern() {\n        if (this.fillPatternImage()) {\n            var ctx = getDummyContext();\n            const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');\n            if (pattern && pattern.setTransform) {\n                const tr = new Transform();\n                tr.translate(this.fillPatternX(), this.fillPatternY());\n                tr.rotate(Konva.getAngle(this.fillPatternRotation()));\n                tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());\n                tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());\n                const m = tr.getMatrix();\n                const matrix = typeof DOMMatrix === 'undefined'\n                    ? {\n                        a: m[0],\n                        b: m[1],\n                        c: m[2],\n                        d: m[3],\n                        e: m[4],\n                        f: m[5],\n                    }\n                    : new DOMMatrix(m);\n                pattern.setTransform(matrix);\n            }\n            return pattern;\n        }\n    }\n    _getLinearGradient() {\n        return this._getCache(linearGradient, this.__getLinearGradient);\n    }\n    __getLinearGradient() {\n        var colorStops = this.fillLinearGradientColorStops();\n        if (colorStops) {\n            var ctx = getDummyContext();\n            var start = this.fillLinearGradientStartPoint();\n            var end = this.fillLinearGradientEndPoint();\n            var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n            for (var n = 0; n < colorStops.length; n += 2) {\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\n            }\n            return grd;\n        }\n    }\n    _getRadialGradient() {\n        return this._getCache(radialGradient, this.__getRadialGradient);\n    }\n    __getRadialGradient() {\n        var colorStops = this.fillRadialGradientColorStops();\n        if (colorStops) {\n            var ctx = getDummyContext();\n            var start = this.fillRadialGradientStartPoint();\n            var end = this.fillRadialGradientEndPoint();\n            var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());\n            for (var n = 0; n < colorStops.length; n += 2) {\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\n            }\n            return grd;\n        }\n    }\n    getShadowRGBA() {\n        return this._getCache(SHADOW_RGBA, this._getShadowRGBA);\n    }\n    _getShadowRGBA() {\n        if (this.hasShadow()) {\n            var rgba = Util.colorToRGBA(this.shadowColor());\n            return ('rgba(' +\n                rgba.r +\n                ',' +\n                rgba.g +\n                ',' +\n                rgba.b +\n                ',' +\n                rgba.a * (this.shadowOpacity() || 1) +\n                ')');\n        }\n    }\n    hasFill() {\n        return this._calculate('hasFill', [\n            'fillEnabled',\n            'fill',\n            'fillPatternImage',\n            'fillLinearGradientColorStops',\n            'fillRadialGradientColorStops',\n        ], () => {\n            return (this.fillEnabled() &&\n                !!(this.fill() ||\n                    this.fillPatternImage() ||\n                    this.fillLinearGradientColorStops() ||\n                    this.fillRadialGradientColorStops()));\n        });\n    }\n    hasStroke() {\n        return this._calculate('hasStroke', [\n            'strokeEnabled',\n            'strokeWidth',\n            'stroke',\n            'strokeLinearGradientColorStops',\n        ], () => {\n            return (this.strokeEnabled() &&\n                this.strokeWidth() &&\n                !!(this.stroke() || this.strokeLinearGradientColorStops()));\n        });\n    }\n    hasHitStroke() {\n        const width = this.hitStrokeWidth();\n        if (width === 'auto') {\n            return this.hasStroke();\n        }\n        return this.strokeEnabled() && !!width;\n    }\n    intersects(point) {\n        var stage = this.getStage(), bufferHitCanvas = stage.bufferHitCanvas, p;\n        bufferHitCanvas.getContext().clear();\n        this.drawHit(bufferHitCanvas, null, true);\n        p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;\n        return p[3] > 0;\n    }\n    destroy() {\n        Node.prototype.destroy.call(this);\n        delete shapes[this.colorKey];\n        delete this.colorKey;\n        return this;\n    }\n    _useBufferCanvas(forceFill) {\n        var _a;\n        if (!this.getStage()) {\n            return false;\n        }\n        const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;\n        if (!perfectDrawEnabled) {\n            return false;\n        }\n        const hasFill = forceFill || this.hasFill();\n        const hasStroke = this.hasStroke();\n        const isTransparent = this.getAbsoluteOpacity() !== 1;\n        if (hasFill && hasStroke && isTransparent) {\n            return true;\n        }\n        const hasShadow = this.hasShadow();\n        const strokeForShadow = this.shadowForStrokeEnabled();\n        if (hasFill && hasStroke && hasShadow && strokeForShadow) {\n            return true;\n        }\n        return false;\n    }\n    setStrokeHitEnabled(val) {\n        Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');\n        if (val) {\n            this.hitStrokeWidth('auto');\n        }\n        else {\n            this.hitStrokeWidth(0);\n        }\n    }\n    getStrokeHitEnabled() {\n        if (this.hitStrokeWidth() === 0) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    getSelfRect() {\n        var size = this.size();\n        return {\n            x: this._centroid ? -size.width / 2 : 0,\n            y: this._centroid ? -size.height / 2 : 0,\n            width: size.width,\n            height: size.height,\n        };\n    }\n    getClientRect(config = {}) {\n        const skipTransform = config.skipTransform;\n        const relativeTo = config.relativeTo;\n        const fillRect = this.getSelfRect();\n        const applyStroke = !config.skipStroke && this.hasStroke();\n        const strokeWidth = (applyStroke && this.strokeWidth()) || 0;\n        const fillAndStrokeWidth = fillRect.width + strokeWidth;\n        const fillAndStrokeHeight = fillRect.height + strokeWidth;\n        const applyShadow = !config.skipShadow && this.hasShadow();\n        const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;\n        const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;\n        const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);\n        const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);\n        const blurRadius = (applyShadow && this.shadowBlur()) || 0;\n        const width = preWidth + blurRadius * 2;\n        const height = preHeight + blurRadius * 2;\n        const rect = {\n            width: width,\n            height: height,\n            x: -(strokeWidth / 2 + blurRadius) +\n                Math.min(shadowOffsetX, 0) +\n                fillRect.x,\n            y: -(strokeWidth / 2 + blurRadius) +\n                Math.min(shadowOffsetY, 0) +\n                fillRect.y,\n        };\n        if (!skipTransform) {\n            return this._transformedRect(rect, relativeTo);\n        }\n        return rect;\n    }\n    drawScene(can, top) {\n        var layer = this.getLayer(), canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferCanvas, bufferContext;\n        var skipBuffer = canvas.isCache;\n        var cachingSelf = top === this;\n        if (!this.isVisible() && !cachingSelf) {\n            return this;\n        }\n        if (cachedCanvas) {\n            context.save();\n            var m = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            this._drawCachedSceneCanvas(context);\n            context.restore();\n            return this;\n        }\n        if (!drawFunc) {\n            return this;\n        }\n        context.save();\n        if (this._useBufferCanvas() && !skipBuffer) {\n            stage = this.getStage();\n            bufferCanvas = stage.bufferCanvas;\n            bufferContext = bufferCanvas.getContext();\n            bufferContext.clear();\n            bufferContext.save();\n            bufferContext._applyLineJoin(this);\n            var o = this.getAbsoluteTransform(top).getMatrix();\n            bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n            drawFunc.call(this, bufferContext, this);\n            bufferContext.restore();\n            var ratio = bufferCanvas.pixelRatio;\n            if (hasShadow) {\n                context._applyShadow(this);\n            }\n            context._applyOpacity(this);\n            context._applyGlobalCompositeOperation(this);\n            context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);\n        }\n        else {\n            context._applyLineJoin(this);\n            if (!cachingSelf) {\n                var o = this.getAbsoluteTransform(top).getMatrix();\n                context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n                context._applyOpacity(this);\n                context._applyGlobalCompositeOperation(this);\n            }\n            if (hasShadow) {\n                context._applyShadow(this);\n            }\n            drawFunc.call(this, context, this);\n        }\n        context.restore();\n        return this;\n    }\n    drawHit(can, top, skipDragCheck = false) {\n        if (!this.shouldDrawHit(top, skipDragCheck)) {\n            return this;\n        }\n        var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\n        if (!this.colorKey) {\n            Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()');\n        }\n        if (cachedHitCanvas) {\n            context.save();\n            var m = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            this._drawCachedHitCanvas(context);\n            context.restore();\n            return this;\n        }\n        if (!drawFunc) {\n            return this;\n        }\n        context.save();\n        context._applyLineJoin(this);\n        const selfCache = this === top;\n        if (!selfCache) {\n            var o = this.getAbsoluteTransform(top).getMatrix();\n            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n        }\n        drawFunc.call(this, context, this);\n        context.restore();\n        return this;\n    }\n    drawHitFromCache(alphaThreshold = 0) {\n        var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len, rgbColorKey, i, alpha;\n        hitContext.clear();\n        hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);\n        try {\n            hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);\n            hitData = hitImageData.data;\n            len = hitData.length;\n            rgbColorKey = Util._hexToRgb(this.colorKey);\n            for (i = 0; i < len; i += 4) {\n                alpha = hitData[i + 3];\n                if (alpha > alphaThreshold) {\n                    hitData[i] = rgbColorKey.r;\n                    hitData[i + 1] = rgbColorKey.g;\n                    hitData[i + 2] = rgbColorKey.b;\n                    hitData[i + 3] = 255;\n                }\n                else {\n                    hitData[i + 3] = 0;\n                }\n            }\n            hitContext.putImageData(hitImageData, 0, 0);\n        }\n        catch (e) {\n            Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);\n        }\n        return this;\n    }\n    hasPointerCapture(pointerId) {\n        return PointerEvents.hasPointerCapture(pointerId, this);\n    }\n    setPointerCapture(pointerId) {\n        PointerEvents.setPointerCapture(pointerId, this);\n    }\n    releaseCapture(pointerId) {\n        PointerEvents.releaseCapture(pointerId, this);\n    }\n}\nShape.prototype._fillFunc = _fillFunc;\nShape.prototype._strokeFunc = _strokeFunc;\nShape.prototype._fillFuncHit = _fillFuncHit;\nShape.prototype._strokeFuncHit = _strokeFuncHit;\nShape.prototype._centroid = false;\nShape.prototype.nodeType = 'Shape';\n_registerNode(Shape);\nShape.prototype.eventListeners = {};\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva', _clearFillPatternCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);\nFactory.addGetterSetter(Shape, 'stroke', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'strokeWidth', 2, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);\nFactory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', getNumberOrAutoValidator());\nFactory.addGetterSetter(Shape, 'strokeHitEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'perfectDrawEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'lineJoin');\nFactory.addGetterSetter(Shape, 'lineCap');\nFactory.addGetterSetter(Shape, 'sceneFunc');\nFactory.addGetterSetter(Shape, 'hitFunc');\nFactory.addGetterSetter(Shape, 'dash');\nFactory.addGetterSetter(Shape, 'dashOffset', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowColor', undefined, getStringValidator());\nFactory.addGetterSetter(Shape, 'shadowBlur', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOpacity', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'shadowOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOffsetY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternImage');\nFactory.addGetterSetter(Shape, 'fill', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'fillPatternX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');\nFactory.addGetterSetter(Shape, 'fillEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeEnabled', true);\nFactory.addGetterSetter(Shape, 'shadowEnabled', true);\nFactory.addGetterSetter(Shape, 'dashEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeScaleEnabled', true);\nFactory.addGetterSetter(Shape, 'fillPriority', 'color');\nFactory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternScaleX', 1, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternScaleY', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', [\n    'x',\n    'y',\n]);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'fillPatternRotation', 0);\nFactory.backCompat(Shape, {\n    dashArray: 'dash',\n    getDashArray: 'getDash',\n    setDashArray: 'getDash',\n    drawFunc: 'sceneFunc',\n    getDrawFunc: 'getSceneFunc',\n    setDrawFunc: 'setSceneFunc',\n    drawHitFunc: 'hitFunc',\n    getDrawHitFunc: 'getHitFunc',\n    setDrawHitFunc: 'setHitFunc',\n});\n"],"sourceRoot":""}