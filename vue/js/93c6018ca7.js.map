{"version":3,"sources":["webpack://webpack-web/./node_modules/_konva@8.3.10@konva/lib/Stage.js"],"names":[],"mappings":"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","file":"js/93c6018ca7.js","sourcesContent":["import { Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Container } from './Container.js';\nimport { Konva } from './Global.js';\nimport { SceneCanvas, HitCanvas } from './Canvas.js';\nimport { DD } from './DragAndDrop.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar STAGE = 'Stage', STRING = 'string', PX = 'px', MOUSEOUT = 'mouseout', MOUSELEAVE = 'mouseleave', MOUSEOVER = 'mouseover', MOUSEENTER = 'mouseenter', MOUSEMOVE = 'mousemove', MOUSEDOWN = 'mousedown', MOUSEUP = 'mouseup', POINTERMOVE = 'pointermove', POINTERDOWN = 'pointerdown', POINTERUP = 'pointerup', POINTERCANCEL = 'pointercancel', LOSTPOINTERCAPTURE = 'lostpointercapture', POINTEROUT = 'pointerout', POINTERLEAVE = 'pointerleave', POINTEROVER = 'pointerover', POINTERENTER = 'pointerenter', CONTEXTMENU = 'contextmenu', TOUCHSTART = 'touchstart', TOUCHEND = 'touchend', TOUCHMOVE = 'touchmove', TOUCHCANCEL = 'touchcancel', WHEEL = 'wheel', MAX_LAYERS_NUMBER = 5, EVENTS = [\n    [MOUSEENTER, '_pointerenter'],\n    [MOUSEDOWN, '_pointerdown'],\n    [MOUSEMOVE, '_pointermove'],\n    [MOUSEUP, '_pointerup'],\n    [MOUSELEAVE, '_pointerleave'],\n    [TOUCHSTART, '_pointerdown'],\n    [TOUCHMOVE, '_pointermove'],\n    [TOUCHEND, '_pointerup'],\n    [TOUCHCANCEL, '_pointercancel'],\n    [MOUSEOVER, '_pointerover'],\n    [WHEEL, '_wheel'],\n    [CONTEXTMENU, '_contextmenu'],\n    [POINTERDOWN, '_pointerdown'],\n    [POINTERMOVE, '_pointermove'],\n    [POINTERUP, '_pointerup'],\n    [POINTERCANCEL, '_pointercancel'],\n    [LOSTPOINTERCAPTURE, '_lostpointercapture'],\n];\nconst EVENTS_MAP = {\n    mouse: {\n        [POINTEROUT]: MOUSEOUT,\n        [POINTERLEAVE]: MOUSELEAVE,\n        [POINTEROVER]: MOUSEOVER,\n        [POINTERENTER]: MOUSEENTER,\n        [POINTERMOVE]: MOUSEMOVE,\n        [POINTERDOWN]: MOUSEDOWN,\n        [POINTERUP]: MOUSEUP,\n        [POINTERCANCEL]: 'mousecancel',\n        pointerclick: 'click',\n        pointerdblclick: 'dblclick',\n    },\n    touch: {\n        [POINTEROUT]: 'touchout',\n        [POINTERLEAVE]: 'touchleave',\n        [POINTEROVER]: 'touchover',\n        [POINTERENTER]: 'touchenter',\n        [POINTERMOVE]: TOUCHMOVE,\n        [POINTERDOWN]: TOUCHSTART,\n        [POINTERUP]: TOUCHEND,\n        [POINTERCANCEL]: TOUCHCANCEL,\n        pointerclick: 'tap',\n        pointerdblclick: 'dbltap',\n    },\n    pointer: {\n        [POINTEROUT]: POINTEROUT,\n        [POINTERLEAVE]: POINTERLEAVE,\n        [POINTEROVER]: POINTEROVER,\n        [POINTERENTER]: POINTERENTER,\n        [POINTERMOVE]: POINTERMOVE,\n        [POINTERDOWN]: POINTERDOWN,\n        [POINTERUP]: POINTERUP,\n        [POINTERCANCEL]: POINTERCANCEL,\n        pointerclick: 'pointerclick',\n        pointerdblclick: 'pointerdblclick',\n    },\n};\nconst getEventType = (type) => {\n    if (type.indexOf('pointer') >= 0) {\n        return 'pointer';\n    }\n    if (type.indexOf('touch') >= 0) {\n        return 'touch';\n    }\n    return 'mouse';\n};\nconst getEventsMap = (eventType) => {\n    const type = getEventType(eventType);\n    if (type === 'pointer') {\n        return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;\n    }\n    if (type === 'touch') {\n        return EVENTS_MAP.touch;\n    }\n    if (type === 'mouse') {\n        return EVENTS_MAP.mouse;\n    }\n};\nfunction checkNoClip(attrs = {}) {\n    if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {\n        Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');\n    }\n    return attrs;\n}\nconst NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;\nexport const stages = [];\nexport class Stage extends Container {\n    constructor(config) {\n        super(checkNoClip(config));\n        this._pointerPositions = [];\n        this._changedPointerPositions = [];\n        this._buildDOM();\n        this._bindContentEvents();\n        stages.push(this);\n        this.on('widthChange.konva heightChange.konva', this._resizeDOM);\n        this.on('visibleChange.konva', this._checkVisibility);\n        this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {\n            checkNoClip(this.attrs);\n        });\n        this._checkVisibility();\n    }\n    _validateAdd(child) {\n        const isLayer = child.getType() === 'Layer';\n        const isFastLayer = child.getType() === 'FastLayer';\n        const valid = isLayer || isFastLayer;\n        if (!valid) {\n            Util.throw('You may only add layers to the stage.');\n        }\n    }\n    _checkVisibility() {\n        if (!this.content) {\n            return;\n        }\n        const style = this.visible() ? '' : 'none';\n        this.content.style.display = style;\n    }\n    setContainer(container) {\n        if (typeof container === STRING) {\n            if (container.charAt(0) === '.') {\n                var className = container.slice(1);\n                container = document.getElementsByClassName(className)[0];\n            }\n            else {\n                var id;\n                if (container.charAt(0) !== '#') {\n                    id = container;\n                }\n                else {\n                    id = container.slice(1);\n                }\n                container = document.getElementById(id);\n            }\n            if (!container) {\n                throw 'Can not find container in document with id ' + id;\n            }\n        }\n        this._setAttr('container', container);\n        if (this.content) {\n            if (this.content.parentElement) {\n                this.content.parentElement.removeChild(this.content);\n            }\n            container.appendChild(this.content);\n        }\n        return this;\n    }\n    shouldDrawHit() {\n        return true;\n    }\n    clear() {\n        var layers = this.children, len = layers.length, n;\n        for (n = 0; n < len; n++) {\n            layers[n].clear();\n        }\n        return this;\n    }\n    clone(obj) {\n        if (!obj) {\n            obj = {};\n        }\n        obj.container =\n            typeof document !== 'undefined' && document.createElement('div');\n        return Container.prototype.clone.call(this, obj);\n    }\n    destroy() {\n        super.destroy();\n        var content = this.content;\n        if (content && Util._isInDocument(content)) {\n            this.container().removeChild(content);\n        }\n        var index = stages.indexOf(this);\n        if (index > -1) {\n            stages.splice(index, 1);\n        }\n        return this;\n    }\n    getPointerPosition() {\n        const pos = this._pointerPositions[0] || this._changedPointerPositions[0];\n        if (!pos) {\n            Util.warn(NO_POINTERS_MESSAGE);\n            return null;\n        }\n        return {\n            x: pos.x,\n            y: pos.y,\n        };\n    }\n    _getPointerById(id) {\n        return this._pointerPositions.find((p) => p.id === id);\n    }\n    getPointersPositions() {\n        return this._pointerPositions;\n    }\n    getStage() {\n        return this;\n    }\n    getContent() {\n        return this.content;\n    }\n    _toKonvaCanvas(config) {\n        config = config || {};\n        config.x = config.x || 0;\n        config.y = config.y || 0;\n        config.width = config.width || this.width();\n        config.height = config.height || this.height();\n        var canvas = new SceneCanvas({\n            width: config.width,\n            height: config.height,\n            pixelRatio: config.pixelRatio || 1,\n        });\n        var _context = canvas.getContext()._context;\n        var layers = this.children;\n        if (config.x || config.y) {\n            _context.translate(-1 * config.x, -1 * config.y);\n        }\n        layers.forEach(function (layer) {\n            if (!layer.isVisible()) {\n                return;\n            }\n            var layerCanvas = layer._toKonvaCanvas(config);\n            _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());\n        });\n        return canvas;\n    }\n    getIntersection(pos) {\n        if (!pos) {\n            return null;\n        }\n        var layers = this.children, len = layers.length, end = len - 1, n;\n        for (n = end; n >= 0; n--) {\n            const shape = layers[n].getIntersection(pos);\n            if (shape) {\n                return shape;\n            }\n        }\n        return null;\n    }\n    _resizeDOM() {\n        var width = this.width();\n        var height = this.height();\n        if (this.content) {\n            this.content.style.width = width + PX;\n            this.content.style.height = height + PX;\n        }\n        this.bufferCanvas.setSize(width, height);\n        this.bufferHitCanvas.setSize(width, height);\n        this.children.forEach((layer) => {\n            layer.setSize({ width, height });\n            layer.draw();\n        });\n    }\n    add(layer, ...rest) {\n        if (arguments.length > 1) {\n            for (var i = 0; i < arguments.length; i++) {\n                this.add(arguments[i]);\n            }\n            return this;\n        }\n        super.add(layer);\n        var length = this.children.length;\n        if (length > MAX_LAYERS_NUMBER) {\n            Util.warn('The stage has ' +\n                length +\n                ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');\n        }\n        layer.setSize({ width: this.width(), height: this.height() });\n        layer.draw();\n        if (Konva.isBrowser) {\n            this.content.appendChild(layer.canvas._canvas);\n        }\n        return this;\n    }\n    getParent() {\n        return null;\n    }\n    getLayer() {\n        return null;\n    }\n    hasPointerCapture(pointerId) {\n        return PointerEvents.hasPointerCapture(pointerId, this);\n    }\n    setPointerCapture(pointerId) {\n        PointerEvents.setPointerCapture(pointerId, this);\n    }\n    releaseCapture(pointerId) {\n        PointerEvents.releaseCapture(pointerId, this);\n    }\n    getLayers() {\n        return this.children;\n    }\n    _bindContentEvents() {\n        if (!Konva.isBrowser) {\n            return;\n        }\n        EVENTS.forEach(([event, methodName]) => {\n            this.content.addEventListener(event, (evt) => {\n                this[methodName](evt);\n            });\n        });\n    }\n    _pointerenter(evt) {\n        this.setPointersPositions(evt);\n        const events = getEventsMap(evt.type);\n        this._fire(events.pointerenter, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n        });\n    }\n    _pointerover(evt) {\n        this.setPointersPositions(evt);\n        const events = getEventsMap(evt.type);\n        this._fire(events.pointerover, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n        });\n    }\n    _getTargetShape(evenType) {\n        let shape = this[evenType + 'targetShape'];\n        if (shape && !shape.getStage()) {\n            shape = null;\n        }\n        return shape;\n    }\n    _pointerleave(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        var targetShape = this._getTargetShape(eventType);\n        var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n        if (targetShape && eventsEnabled) {\n            targetShape._fireAndBubble(events.pointerout, { evt: evt });\n            targetShape._fireAndBubble(events.pointerleave, { evt: evt });\n            this._fire(events.pointerleave, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n            this[eventType + 'targetShape'] = null;\n        }\n        else if (eventsEnabled) {\n            this._fire(events.pointerleave, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n            this._fire(events.pointerout, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n        this.pointerPos = undefined;\n        this._pointerPositions = [];\n    }\n    _pointerdown(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        var triggeredOnShape = false;\n        this._changedPointerPositions.forEach((pos) => {\n            var shape = this.getIntersection(pos);\n            DD.justDragged = false;\n            Konva['_' + eventType + 'ListenClick'] = true;\n            const hasShape = shape && shape.isListening();\n            if (!hasShape) {\n                return;\n            }\n            if (Konva.capturePointerEventsEnabled) {\n                shape.setPointerCapture(pos.id);\n            }\n            this[eventType + 'ClickStartShape'] = shape;\n            shape._fireAndBubble(events.pointerdown, {\n                evt: evt,\n                pointerId: pos.id,\n            });\n            triggeredOnShape = true;\n            const isTouch = evt.type.indexOf('touch') >= 0;\n            if (shape.preventDefault() && evt.cancelable && isTouch) {\n                evt.preventDefault();\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointerdown, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._pointerPositions[0].id,\n            });\n        }\n    }\n    _pointermove(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        if (DD.isDragging && DD.node.preventDefault() && evt.cancelable) {\n            evt.preventDefault();\n        }\n        this.setPointersPositions(evt);\n        var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n        if (!eventsEnabled) {\n            return;\n        }\n        var processedShapesIds = {};\n        let triggeredOnShape = false;\n        var targetShape = this._getTargetShape(eventType);\n        this._changedPointerPositions.forEach((pos) => {\n            const shape = (PointerEvents.getCapturedShape(pos.id) ||\n                this.getIntersection(pos));\n            const pointerId = pos.id;\n            const event = { evt: evt, pointerId };\n            var differentTarget = targetShape !== shape;\n            if (differentTarget && targetShape) {\n                targetShape._fireAndBubble(events.pointerout, Object.assign({}, event), shape);\n                targetShape._fireAndBubble(events.pointerleave, Object.assign({}, event), shape);\n            }\n            if (shape) {\n                if (processedShapesIds[shape._id]) {\n                    return;\n                }\n                processedShapesIds[shape._id] = true;\n            }\n            if (shape && shape.isListening()) {\n                triggeredOnShape = true;\n                if (differentTarget) {\n                    shape._fireAndBubble(events.pointerover, Object.assign({}, event), targetShape);\n                    shape._fireAndBubble(events.pointerenter, Object.assign({}, event), targetShape);\n                    this[eventType + 'targetShape'] = shape;\n                }\n                shape._fireAndBubble(events.pointermove, Object.assign({}, event));\n            }\n            else {\n                if (targetShape) {\n                    this._fire(events.pointerover, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                    this[eventType + 'targetShape'] = null;\n                }\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointermove, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._changedPointerPositions[0].id,\n            });\n        }\n    }\n    _pointerup(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        const clickStartShape = this[eventType + 'ClickStartShape'];\n        const clickEndShape = this[eventType + 'ClickEndShape'];\n        var processedShapesIds = {};\n        let triggeredOnShape = false;\n        this._changedPointerPositions.forEach((pos) => {\n            const shape = (PointerEvents.getCapturedShape(pos.id) ||\n                this.getIntersection(pos));\n            if (shape) {\n                shape.releaseCapture(pos.id);\n                if (processedShapesIds[shape._id]) {\n                    return;\n                }\n                processedShapesIds[shape._id] = true;\n            }\n            const pointerId = pos.id;\n            const event = { evt: evt, pointerId };\n            let fireDblClick = false;\n            if (Konva['_' + eventType + 'InDblClickWindow']) {\n                fireDblClick = true;\n                clearTimeout(this[eventType + 'DblTimeout']);\n            }\n            else if (!DD.justDragged) {\n                Konva['_' + eventType + 'InDblClickWindow'] = true;\n                clearTimeout(this[eventType + 'DblTimeout']);\n            }\n            this[eventType + 'DblTimeout'] = setTimeout(function () {\n                Konva['_' + eventType + 'InDblClickWindow'] = false;\n            }, Konva.dblClickWindow);\n            if (shape && shape.isListening()) {\n                triggeredOnShape = true;\n                this[eventType + 'ClickEndShape'] = shape;\n                shape._fireAndBubble(events.pointerup, Object.assign({}, event));\n                if (Konva['_' + eventType + 'ListenClick'] &&\n                    clickStartShape &&\n                    clickStartShape === shape) {\n                    shape._fireAndBubble(events.pointerclick, Object.assign({}, event));\n                    if (fireDblClick && clickEndShape && clickEndShape === shape) {\n                        shape._fireAndBubble(events.pointerdblclick, Object.assign({}, event));\n                    }\n                }\n            }\n            else {\n                this[eventType + 'ClickEndShape'] = null;\n                if (Konva['_' + eventType + 'ListenClick']) {\n                    this._fire(events.pointerclick, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                }\n                if (fireDblClick) {\n                    this._fire(events.pointerdblclick, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                }\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointerup, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._changedPointerPositions[0].id,\n            });\n        }\n        Konva['_' + eventType + 'ListenClick'] = false;\n        if (evt.cancelable) {\n            evt.preventDefault();\n        }\n    }\n    _contextmenu(evt) {\n        this.setPointersPositions(evt);\n        var shape = this.getIntersection(this.getPointerPosition());\n        if (shape && shape.isListening()) {\n            shape._fireAndBubble(CONTEXTMENU, { evt: evt });\n        }\n        else {\n            this._fire(CONTEXTMENU, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n    }\n    _wheel(evt) {\n        this.setPointersPositions(evt);\n        var shape = this.getIntersection(this.getPointerPosition());\n        if (shape && shape.isListening()) {\n            shape._fireAndBubble(WHEEL, { evt: evt });\n        }\n        else {\n            this._fire(WHEEL, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n    }\n    _pointercancel(evt) {\n        this.setPointersPositions(evt);\n        const shape = PointerEvents.getCapturedShape(evt.pointerId) ||\n            this.getIntersection(this.getPointerPosition());\n        if (shape) {\n            shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));\n        }\n        PointerEvents.releaseCapture(evt.pointerId);\n    }\n    _lostpointercapture(evt) {\n        PointerEvents.releaseCapture(evt.pointerId);\n    }\n    setPointersPositions(evt) {\n        var contentPosition = this._getContentPosition(), x = null, y = null;\n        evt = evt ? evt : window.event;\n        if (evt.touches !== undefined) {\n            this._pointerPositions = [];\n            this._changedPointerPositions = [];\n            Array.prototype.forEach.call(evt.touches, (touch) => {\n                this._pointerPositions.push({\n                    id: touch.identifier,\n                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,\n                });\n            });\n            Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {\n                this._changedPointerPositions.push({\n                    id: touch.identifier,\n                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,\n                });\n            });\n        }\n        else {\n            x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;\n            y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;\n            this.pointerPos = {\n                x: x,\n                y: y,\n            };\n            this._pointerPositions = [{ x, y, id: Util._getFirstPointerId(evt) }];\n            this._changedPointerPositions = [\n                { x, y, id: Util._getFirstPointerId(evt) },\n            ];\n        }\n    }\n    _setPointerPosition(evt) {\n        Util.warn('Method _setPointerPosition is deprecated. Use \"stage.setPointersPositions(event)\" instead.');\n        this.setPointersPositions(evt);\n    }\n    _getContentPosition() {\n        if (!this.content || !this.content.getBoundingClientRect) {\n            return {\n                top: 0,\n                left: 0,\n                scaleX: 1,\n                scaleY: 1,\n            };\n        }\n        var rect = this.content.getBoundingClientRect();\n        return {\n            top: rect.top,\n            left: rect.left,\n            scaleX: rect.width / this.content.clientWidth || 1,\n            scaleY: rect.height / this.content.clientHeight || 1,\n        };\n    }\n    _buildDOM() {\n        this.bufferCanvas = new SceneCanvas({\n            width: this.width(),\n            height: this.height(),\n        });\n        this.bufferHitCanvas = new HitCanvas({\n            pixelRatio: 1,\n            width: this.width(),\n            height: this.height(),\n        });\n        if (!Konva.isBrowser) {\n            return;\n        }\n        var container = this.container();\n        if (!container) {\n            throw 'Stage has no container. A container is required.';\n        }\n        container.innerHTML = '';\n        this.content = document.createElement('div');\n        this.content.style.position = 'relative';\n        this.content.style.userSelect = 'none';\n        this.content.className = 'konvajs-content';\n        this.content.setAttribute('role', 'presentation');\n        container.appendChild(this.content);\n        this._resizeDOM();\n    }\n    cache() {\n        Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');\n        return this;\n    }\n    clearCache() {\n        return this;\n    }\n    batchDraw() {\n        this.getChildren().forEach(function (layer) {\n            layer.batchDraw();\n        });\n        return this;\n    }\n}\nStage.prototype.nodeType = STAGE;\n_registerNode(Stage);\nFactory.addGetterSetter(Stage, 'container');\n"],"sourceRoot":""}